8.11
# In the data science, there exists the concept of stemming, which is heuristic of chopping off the end of a word to clean and bucket it into an easier feature set.
# Given a dictionary consisting of many roots and a sentence, write a function replace_words to stem all the words in the sentence with the root forming it. If a word has many roots that can form it, replace it with the root with the sortest length.
Example:
Input:
root = ["cat", "bat", "rat"]
sentence = "the cattle was rattled by the battery"
Output:
"the cat was rat by the bat"

def replace_words(root, sentence):
  words = sentence.split()
  j=0
  while j<len(words):
    i = 0
    while i<len(words[j]):
      if words[j][:i] in roots:
        words[j] = words[j][:i]
        i = len(words[j])
      i = i+1
    j = j+1
  new_sentence = " ".join(words)
  return(new_sentence)


8.18
# Write a function find_change to find the minimum number of coins that make up the given amount of change cents.
# Assume we only have coins of value 1,5,10, and 25 cents.
Example:
Input:
cents = 73
Output:
def find_change(cents) -> 7
#(25+25+10+10+1+1+1)

def minimum_change(cents):
  count = 0
  while cents != 0:
    if cents >= 25:
      count +=1
      cents -=25
    elif cents >=10:
      count +=1
      cents -=10
    elif cents >= 5:
      count +=1
      cents -=5
    elif cents >=1:
      count +=1
      cents -=1
  return count
  
  
  8.23
  # You have an array of integers of length n spanning 0 to n with one missing.
  # Write a function missing_number that returns the missing number in the array.
  # Note: Complexity of O(N) required.
  
  Example:
  Imput:
  nums = [0, 1, 2, 4, 5]
  missing_number(nums) -> 3
  
  def missing_number(nums):
    num_set = set(nums)
    n = len(nums) + 1
    for number in range(n):
      if number not in num_set:
        return number

def missing_number(nums):
  n = len(nums)
  total = n*(n+1)/2
  sum_of_nums = sum(nums)
  return total - sum_of_nums
  
  
8.29
Given an array of integers, write a function move_zeros_back that moves all zeros in the array to the end of the array.
If there are no zeros, return the input array.

Example:
Input:
array = [0,5,4,2,0,3]
def move_zeros_back(array) -> [5,4,2,3,0,0]

def move_zeros_back(array):
  non_zeros = 0
  for i in range (len(array)):
    if array[i] == 0:
      while array[non_zeros] == 0:
        non_zeros += 1
        if non_zeros >= len(array):
          return array
      array[non_zeros], array[i] = array[i], array[non_zeros]
  return array



